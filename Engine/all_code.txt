#pragma once

#ifdef ENGINE_EXPORTS
#define ENGINE_API __declspec(dllexport)
#else
#define ENGINE_API __declspec(dllimport)
#endif#pragma once

#include <map>
#include <string>

#include <SFML/Audio/Sound.hpp>
#include <SFML/Audio/SoundBuffer.hpp>
#include <SFML/Graphics.hpp>
#include <rttr/registration_friend.h>

#include "EngineAPI.h"
#include "Graphics/Animation.h"
#include "Reflection/ReflectionMacros.h"

namespace Luden {

	class ENGINE_API Assets 
	{
		RTTR_REGISTRATION_FRIEND

		std::map<std::string, sf::Texture>	m_Textures;
		std::map<std::string, sf::Font>	m_Fonts;
		std::map<std::string, sf::SoundBuffer> m_SoundBuffers;
		std::map<std::string, sf::Sound> m_Sounds;
		std::map<std::string, Graphics::Animation> m_Animations;

	public:
		Assets() = default;

		~Assets() = default;

		void LoadFromFile(const std::string& path);

		void AddTexture(const std::string& name, const std::string& path);
		void AddFont(const std::string& name, const std::string& path);
		void AddSound(const std::string& name, const std::string& path);
		void AddAnimation(const std::string& name, const Graphics::Animation& animation);

		sf::Texture& GetTexture(const std::string& name);
		sf::Font& GetFont(const std::string& name);
		sf::Sound& GetSound(const std::string& name);
		Graphics::Animation& GetAnimation(const std::string& name);
	};

}
#pragma once

#include <map>
#include <memory>
#include <string>

#include <SFML/Graphics/RenderWindow.hpp>
#include <SFML/System/Clock.hpp>
#include <rttr/registration_friend.h>
#include <rttr/rttr_enable.h>

#include "Asset/Asset.h"
#include "EngineAPI.h"
#include "Scene/Scene.h"


namespace Luden {

	using SceneMap = std::map<std::string, std::shared_ptr<Scene>>;

	class ENGINE_API GameEngine {
	private:
		RTTR_ENABLE()
		RTTR_REGISTRATION_FRIEND
		static GameEngine* s_Instance;

		GameEngine(const std::string& assetPath);
		~GameEngine();

		void Init(const std::string& assetPath);

		sf::RenderWindow m_Window;
		sf::Clock m_DeltaClock;
		Assets  m_Assets;

		std::string m_CurrentSceneName;
		SceneMap m_SceneMap;

		bool m_IsRunning = true;

		void ProcessInput();

	public:
		GameEngine(const GameEngine&) = delete;
		GameEngine& operator=(const GameEngine&) = delete;

		static void Initialize(const std::string& assetPath);
		static void Shutdown();
		void Run();
		bool IsRunning() const;
		void Quit();

		void ChangeScene(const std::string& name, std::shared_ptr<Scene> scene, bool endCurrent = false);
		
		std::shared_ptr<Scene> GetCurrentScene();
		static GameEngine& Get();
		sf::RenderWindow& GetWindow();
		Assets& GetAssets();

	private:
		void Update();
	};
} 
#include "ECS/EntityManager.h"

namespace Luden
{
	Entity EntityManager::AddEntity(const std::string& tag) {
		Entity e = EntityMemoryPool::Instance().AddEntity(tag);
		m_entitiesToAdd.push_back(e);
		return e;
	}
}

#pragma once

#include <cstdint>
#include <string>
#include <tuple>
#include <vector>

#include <rttr/registration_friend.h>

#include "ECS/IComponent.h"
#include "ECS/EntityManager.h"
#include "EngineAPI.h"

namespace Luden 
{
	class EntityManager;

	using EntityID = std::size_t;

	class ENGINE_API Entity
	{
		RTTR_REGISTRATION_FRIEND

	private:
		friend class EntityManager;

		EntityID m_ID = 0;

		Entity() = default;
		explicit Entity(EntityID id);

	public:
		void Destroy();

		[[nodiscard]] EntityID Id() const;

		[[nodiscard]] bool IsActive() const;

		[[nodiscard]] const std::string& Tag() const;

		template<class T>
		bool Has() const 
		{
			return EntityManager::Instance().HasComponent<T>(m_ID);
		}

		template<class T, typename... TArgs>
		T& Add(TArgs&&... args)
		{
			auto& component = EntityManager::Instance().template AddComponent<T>(m_ID, std::forward<TArgs>(args)...);
			return component;
		}

		template<class T>
		T& Get() {
			return EntityManager::Instance().GetComponent<T>(m_ID);
		}

		template<class T>
		const T& Get() const {
			return EntityManager::Instance().GetComponent<T>(m_ID);
		}

		template<class T>
		void Remove() const {
			EntityManager::Instance().RemoveComponent<T>(m_ID);
		}
	};
}#pragma once

#include <cassert>
#include <memory>
#include <string>
#include <tuple>
#include <vector>

#include <rttr/registration_friend.h>

#include "ECS/Components/Components.h"
#include "Reflection/ReflectionMacros.h"

#define MAX_ENTITIES 100000

namespace Luden
{
	class Entity;
	using EntityID = std::size_t;

	using EntityComponentVectorTuple = std::tuple<
		std::vector<Luden::CDamage>,
		std::vector<Luden::CDraggable>,
		std::vector<Luden::CFollowPlayer>,
		std::vector<Luden::CGravity>,
		std::vector<Luden::CHealth>,
		std::vector<Luden::CInput>,
		std::vector<Luden::CBoundingBox>,
		std::vector<Luden::CAnimation>,
		std::vector<Luden::CLifespan>,
		std::vector<Luden::CInvincibility>,
		std::vector<Luden::CPatrol>,
		std::vector<Luden::CState>,
		std::vector<Luden::CTransform>
	>;

	class ENGINE_API EntityManager
	{
		RTTR_REGISTRATION_FRIEND

		size_t m_NumEntities = 0;
		EntityComponentVectorTuple m_Pool;
		std::vector<std::string> m_Tags;
		std::vector<bool> m_Active;

		EntityManager(size_t maxEntities);
		EntityID GetNextIndex();

	public:
		static EntityManager& Instance()
		{
			static EntityManager instance(MAX_ENTITIES);
			return instance;
		}

		void DestroyEntity(EntityID entityID);

		template <typename T>
		T& GetComponent(EntityID entityID)
		{
			return std::get<std::vector<T>>(m_Pool)[entityID];
		}

		template <typename T>
		void RemoveComponent(EntityID entityID)
		{
			std::get<std::vector<T>>(m_Pool)[entityID].has = false;
		}

		template <typename T, typename... TArgs>
		T& AddComponent(EntityID entityID, TArgs&&... args)
		{
			auto& component = GetComponent<T>(entityID);
			component = T(std::forward<TArgs>(args)...);
			component.has = true;
			return component;
		}

		template <typename T>
		bool HasComponent(EntityID entityID) const
		{
			return std::get<std::vector<T>>(m_Pool)[entityID].has;
		}

		const std::string& GetTag(EntityID entityID) const
		{
			return m_Tags[entityID];
		}

		bool IsActive(EntityID entityID) const
		{
			return m_Active[entityID];
		}

		Entity AddEntity(const std::string& tag);
	};
}
#pragma once

#include <rttr/type.h>
#include <rttr/rttr_enable.h>

#include "EngineAPI.h"
#include "Reflection/ReflectionMacros.h"

namespace Luden 
{
	struct ENGINE_API IComponent 
	{
	public:
		bool has = false;
		RTTR_ENABLE();
	};
}#include <rttr/rttr_enable.h>

#include "EngineAPI.h"
#include "Reflection/ReflectionMacros.h"

namespace Luden
{
	class ENGINE_API ISystem
	{
	public:
		virtual ~ISystem() = default;
		virtual void Update(float dt) = 0;
		RTTR_ENABLE();
	};
}
#pragma once

#include "ECS/IComponent.h"
#include "Graphics/Animation.h"
#include "Math/Vec2.h"
#include "Reflection/ReflectionMacros.h"
#include <rttr/registration.h>

namespace Luden
{
	struct ENGINE_API CDamage : public IComponent 
	{
	public:
		int damage = 1;

		CDamage() = default;

		explicit CDamage(int d) : damage(d) {}
		RTTR_ENABLE(IComponent);
	};

	struct ENGINE_API CDraggable : public IComponent
	{
	public:
		bool dragging = false;

		CDraggable() = default;
		RTTR_ENABLE(IComponent);
	};

	struct ENGINE_API CFollowPlayer : public IComponent
	{
	public:
		Math::Vec2 home = { 0.0f, 0.0f };
		float speed = 0.0f;

		CFollowPlayer() = default;

		CFollowPlayer(Math::Vec2 p, float s) : home(p), speed(s) {}
		RTTR_ENABLE(IComponent);
	};

	struct ENGINE_API CGravity : public IComponent
	{
	public:
		float gravity = 0;

		CGravity() = default;

		explicit CGravity(float g) : gravity(g) {}
		RTTR_ENABLE(IComponent);
	};

	struct ENGINE_API CHealth : public IComponent
	{
	public:
		int max = 1;
		int current = 1;

		CHealth() = default;

		CHealth(int m, int c) : max(m), current(c) {}
		RTTR_ENABLE(IComponent);
	};

	struct ENGINE_API CInput : public IComponent
	{
	public:
		bool up = false;
		bool down = false;
		bool left = false;
		bool right = false;
		bool attack = false;
		bool canAttack = true;

		CInput() = default;
		RTTR_ENABLE(IComponent);
	};

	struct ENGINE_API CBoundingBox : public IComponent
	{
	public:
		Math::Vec2 size;
		Math::Vec2 halfSize;
		Math::Vec2 center;
		Math::Vec2 prevCenter;
		bool blockMove = false;
		bool blockVision = false;

		CBoundingBox() = default;

		CBoundingBox(const Math::Vec2& c, const Math::Vec2& s, bool m, bool v)
			: size(s), halfSize(s.x / 2.0f, s.y / 2.0f), center(c), prevCenter(c), blockMove(m), blockVision(v) {}
		RTTR_ENABLE(IComponent);
	};

	struct ENGINE_API CAnimation : public IComponent
	{
	public:
		Graphics::Animation* animation = nullptr;
		bool repeat = false;

		CAnimation() = default;

		CAnimation(Graphics::Animation a, bool r) : animation(&a), repeat(r) {}
		RTTR_ENABLE(IComponent);
	};

	struct ENGINE_API CInvincibility : public IComponent
	{
	public:
		int iframes = 1;

		CInvincibility() = default;

		explicit CInvincibility(int f) : iframes(f) {}
		RTTR_ENABLE(IComponent);
	};

	struct ENGINE_API CLifespan : public IComponent
	{
	public:
		int lifespan = 0;
		int frameCreated = 0;

		CLifespan() = default;

		explicit CLifespan(int duration, int frame)
			: lifespan(duration), frameCreated(frame) {}
		RTTR_ENABLE(IComponent);
	};

	struct ENGINE_API CPatrol : public IComponent
	{
	public:
		std::vector<Math::Vec2> positions;
		size_t currentPosition = 0;
		float speed = 0;

		CPatrol() = default;

		CPatrol(std::vector<Math::Vec2>& pos, float s) : positions(pos), speed(s) {}
		RTTR_ENABLE(IComponent);
	};

	struct ENGINE_API CState : public IComponent
	{
	public:
		std::string state = "stand";
		std::string previousState = "stand";
		bool changeAnimation = false;

		CState() = default;

		explicit CState(std::string s) : state(std::move(s)) {}
		RTTR_ENABLE(IComponent);
	};

	struct ENGINE_API CTransform : public IComponent
	{
	public:
		Math::Vec2 pos = { 0.0f, 0.0f };
		Math::Vec2 prevPos = { 0.0f, 0.0f };
		Math::Vec2 velocity = { 0.0f, 0.0f };
		Math::Vec2 scale = { 1.0f, 1.0f };
		Math::Vec2 facing = { 0.0f, 1.0f };
		float angle = 0;

		CTransform() = default;

		explicit CTransform(const Math::Vec2& p) : pos(p) {}

		CTransform(const Math::Vec2& p, const Math::Vec2& speed, const Math::Vec2& s, float a)
			: pos(p), prevPos(p), velocity(speed), scale(s), angle(a) {}
		RTTR_ENABLE(IComponent);
	};
}#pragma once

#include <string>

#include <SFML/Graphics.hpp>
#include <rttr/registration_friend.h>

#include "EngineAPI.h"
#include "Math/Vec2.h"
#include "Reflection/ReflectionMacros.h"

namespace Luden::Graphics
{
	class ENGINE_API Animation
	{
		RTTR_REGISTRATION_FRIEND

		sf::Sprite m_Sprite;
		size_t m_FrameCount = 1;
		size_t m_CurrentFrame = 0;
		size_t m_Speed = 0;
		Math::Vec2 m_Size = { 1, 1 };
		std::string m_Name = "none";

	public:
		Animation() = delete;
		Animation(const std::string& name, const sf::Texture& texture);
		Animation(const std::string& name, const sf::Texture& texture, size_t frameCount, size_t speed);

		void Update();
		bool HasEnded() const;

		const std::string& GetName() const;
		const Math::Vec2& GetSize() const;

		const sf::Sprite& GetSprite() const;
		sf::Sprite& GetSprite();
	};
}
#pragma once

#include <string>

#include <rttr/registration_friend.h>

#include "EngineAPI.h"
#include "Math/Vec2.h"
#include "Reflection/ReflectionMacros.h"

namespace Luden {

	class ENGINE_API Action 
	{
	private:
		RTTR_REGISTRATION_FRIEND

		std::string m_Name;
		std::string m_Type;
		Math::Vec2 m_Pos = { 0.0f, 0.0f };

	public:
		Action() = default;
		Action(std::string name, std::string type);
		Action(std::string name, Math::Vec2 pos);
		Action(std::string name, std::string type, Math::Vec2 pos);

		[[nodiscard]] const std::string& Name() const;
		[[nodiscard]] const std::string& Type() const;
		[[nodiscard]] const Math::Vec2& Pos() const;

		[[nodiscard]] std::string ToString() const;
	};
}
#pragma once

#include "EngineAPI.h"
#include "Reflection/ReflectionMacros.h"

namespace Luden::Math
{
	struct ENGINE_API Vec2 {
		float x = 0;
		float y = 0;

		static float epsilon;
		static const Vec2 kZero;

		Vec2();

		Vec2(float xin, float yin);


		Vec2 operator*(float val) const;

		Vec2 operator/(float val) const;

		Vec2 operator+=(Vec2 rhs);

		Vec2 operator-=(Vec2 rhs);

		Vec2 operator*=(float val);

		Vec2 operator/=(float val);


		bool operator==(const Vec2& rhs) const;

		bool operator!=(const Vec2& rhs) const;

		[[nodiscard]] float Length() const;

		[[nodiscard]] float LengthSquared() const;

		Vec2 Normalize();
	};

	struct ENGINE_API Point2 {
		float x = 0;
		float y = 0;

		static float epsilon;
		static const Point2 kOrigin;

		Point2();

		Point2(float xin, float yin);

		bool operator==(const Point2& rhs) const;

		bool operator!=(const Point2& rhs) const;

		[[nodiscard]] float Distance(Point2 p) const;

		[[nodiscard]] float DistanceSquared(Point2 p) const;
	};

	Vec2 operator+(Vec2 lhs, Vec2 rhs);

	Point2 operator+(Point2 lhs, Vec2 rhs);

	Vec2 operator-(Vec2 lhs, Vec2 rhs);

	Vec2 operator-(Point2 lhs, Point2 rhs);

	Vec2 operator*(float val, Vec2 lhs);

	bool Equals(Vec2 lhs, Vec2 rhs);

	bool Equals(Point2 lhs, Point2 rhs);

	float Length(Vec2 a);

	float LengthSquared(Vec2 a);

	Vec2 Normalize(Vec2 a);

	float Dot(Vec2 lhs, Vec2 rhs);

	float Distance(Point2 lhs, Point2 rhs);

	float DistanceSquared(Point2 lhs, Point2 rhs);

	float AngleRadians(Vec2 lhs, Vec2 rhs);

	float AngleDegrees(Vec2 lhs, Vec2 rhs);

	bool Clockwise(Vec2 lhs, Vec2 rhs);

	bool CounterClockwise(Vec2 lhs, Vec2 rhs);
}


#pragma once

#include <memory>

#include "ECS/Entity.h"
#include "EngineAPI.h"
#include "Math/Vec2.h"

namespace Luden
{
	struct ENGINE_API Intersect
	{
		bool hit = false;
		Math::Vec2 position = { 0.0f, 0.0f };
	};

	enum struct ODirection {
		UP,
		DOWN,
		LEFT,
		RIGHT,
		NONE
	};

	struct ENGINE_API RectOverlap {
		ODirection m_Direction = ODirection::NONE;
		Math::Vec2 m_Overlap = { 0.0f, 0.0f };
	};

	class ENGINE_API Physics
	{
	public:
		static Math::Vec2 GetOverlap(const std::shared_ptr<Entity>& a, const std::shared_ptr<Entity>& b);

		static Math::Vec2 GetPreviousOverlap(const std::shared_ptr<Entity>& a, const std::shared_ptr<Entity>& b);

		static bool IsInside(const Math::Vec2& pos, const std::shared_ptr<Entity>& entity);

		static Intersect LineIntersect(const Math::Vec2& a, const Math::Vec2& b, const Math::Vec2& c, const Math::Vec2& d);

		static bool EntityIntersect(const Math::Vec2& a, const Math::Vec2& b, const std::shared_ptr<Entity>& entity);

		static RectOverlap AIsNearB(const std::shared_ptr<Entity>& a, const std::shared_ptr<Entity>& b, const Math::Vec2& maxDist);

		static Math::Vec2 GetSpeedAB(const Math::Vec2& posA, const Math::Vec2& posB, float speed);
	};
}
#pragma once

#define CLASS()
#define COMPONENT()
#define PROPERTY()
#pragma once
#pragma once

#include <map>
#include <memory>
#include <string>

#include <SFML/Window.hpp>
#include <rttr/registration_friend.h>
#include <rttr/rttr_enable.h>

#include "EngineAPI.h"
#include "ECS/EntityManager.h"
#include "Input/Action.h"
#include "Math/Vec2.h"

namespace Luden {

	class GameEngine;
	using ActionMap = std::map<int, std::string>;

	class ENGINE_API Scene {
		RTTR_ENABLE()
		RTTR_REGISTRATION_FRIEND
	protected:
		GameEngine* m_Game = nullptr;

		ActionMap m_ActionMap;
		bool m_Paused = false;
		bool m_HasEnded = false;
		size_t m_CurrentFrame = 0;

		void SetPaused(bool paused);

	public:
		Scene() = default;
		explicit Scene(GameEngine* gameEngine);
		virtual ~Scene() = default;

		virtual void Update() = 0;
		virtual void sRender() = 0;
		virtual void sDoAction(const Action& action) = 0;
		virtual void OnEnd() = 0;

		virtual void DoAction(const Action& action);
		void Simulate(size_t frames);
		void RegisterAction(sf::Keyboard::Key inputKey, const std::string& actionName);

		[[nodiscard]] float Width() const;
		[[nodiscard]] float Height() const;
		[[nodiscard]] size_t CurrentFrame() const;
		[[nodiscard]] bool HasEnded() const;
		[[nodiscard]] const ActionMap& GetActionMap() const;

		void DrawLine(const Math::Vec2& p1, const Math::Vec2& p2);
	};

}
#pragma once

#include "Input/Action.h"
#include "Scene/Scene.h"

#include <SFML/Audio/Sound.hpp>
#include <SFML/Graphics/Text.hpp>
#include <rttr/rttr_enable.h>
#include <rttr/registration_friend.h>

namespace Luden
{
	class ENGINE_API Scene_Menu : public Luden::Scene 
	{
		RTTR_ENABLE(Scene)
		RTTR_REGISTRATION_FRIEND

		sf::Text m_MenuText;
		std::vector<std::string> m_MenuStrings;
		std::vector<sf::Text> m_MenuItems;
		sf::Sound& m_TitleMusic;
		std::string m_Title;
		int m_SelectedMenuIndex = 0;

		std::vector<std::string> m_LevelPaths;

		void Init();

	public:
		Scene_Menu(Luden::GameEngine* game);

		void sRender() override;
		void sDoAction(const Action& action) override;
		void Update() override;
		void OnEnd() override;
	};
}

#pragma once

#include <memory>

#include <SFML/Graphics/Text.hpp>
#include <rttr/rttr_enable.h>
#include <rttr/registration_friend.h>

#include "Core/GameEngine.h"
#include "ECS/Entity.h"
#include "Scene/Scene.h"

namespace Luden
{
	class ENGINE_API Scene_Zelda : public Scene 
	{
		RTTR_ENABLE(Scene)
		RTTR_REGISTRATION_FRIEND

		std::string m_LevelPath;
		sf::Text m_GridText;
		Math::Vec2 m_MousePos;
		Math::Vec2 m_GridSize = { 64, 64 };

		bool m_DrawTextures = true;
		bool m_DrawCollision = false;
		bool m_DrawGrid = false;
		bool m_Follow = false;

		struct ENGINE_API PlayerConfig 
		{
			float X, Y, CX, CY, SPEED;
			int HEALTH;
		} m_PlayerConfig;

		void Init(const std::string& levelPath);
		void LoadLevel(const std::string& fileName);
		void SpawnPlayer();
		void SpawnSword(const Entity& entity);

		void player();
		Math::Vec2 GetPosition(int rx, int ry, int tx, int ty) const;
		Math::Vec2 GetRoomXY(const Math::Vec2& pos);
		Math::Vec2 WindowToWorld(const Math::Vec2& pos);
		void ChangePlayerStateTo(const std::string& state, const Math::Vec2& facing);

		void sDrag();
		void sCamera();
		void sGUI();

	public:
		Scene_Zelda(Luden::GameEngine* game, std::string& levelPath);

		void Update() override;
		void sRender() override;
		void sDoAction(const Action& action) override;
		void OnEnd() override;

		void sAI();
		void sStatus();
		void sAnimation();
		void sCollision();
		void sMovement();
	};
}

#include <SFML/Graphics.hpp>
#include "Core/GameEngine.h"

namespace Luden
{
	int main() {
		GameEngine::Initialize("config/assets.txt");
		GameEngine::Get().Run();

		return 0;
	}
}
#include "Asset/Asset.h"

#include <cassert>
#include <fstream>
#include <iostream>

namespace Luden {

	void Assets::LoadFromFile(const std::string& path) {
		std::ifstream file(path);
		if (!file) {
			std::cerr << "Could not load asset file: " << path << "\n";
			exit(-1);
		}

		std::string assetType;
		while (file >> assetType) {
			if (assetType == "Texture") {
				std::string name, filePath;
				file >> name >> filePath;
				AddTexture(name, filePath);
			}
			else if (assetType == "Font") {
				std::string name, filePath;
				file >> name >> filePath;
				AddFont(name, filePath);
			}
			else if (assetType == "Sound") {
				std::string name, filePath;
				file >> name >> filePath;
				AddSound(name, filePath);
			}
			else if (assetType == "Animation") {
				std::string name, textureName;
				int frameCount, speed;
				file >> name >> textureName >> frameCount >> speed;

				auto& texture = GetTexture(textureName);
				AddAnimation(name, Graphics::Animation(name, texture, frameCount, speed));
			}
			else {
				std::cerr << "Unknown asset type: " << assetType << "\n";
				exit(-1);
			}
		}
	}

	void Assets::AddTexture(const std::string& name, const std::string& path) {
		sf::Texture texture;
		if (!texture.loadFromFile(path)) {
			std::cerr << "Failed to load texture: " << path << "\n";
			exit(-1);
		}
		m_Textures[name] = texture;
	}

	void Assets::AddFont(const std::string& name, const std::string& path) {
		sf::Font font;
		if (!font.openFromFile(path)) 
		{
			std::cerr << "Failed to load font: " << path << "\n";
			exit(-1);
		}
		m_Fonts[name] = font;
	}

	void Assets::AddSound(const std::string& name, const std::string& path)
	{
		sf::SoundBuffer buffer;
		if (!buffer.loadFromFile(path)) {
			std::cerr << "Failed to load sound: " << path << "\n";
			exit(-1);
		}
		m_SoundBuffers[name] = buffer;;
		m_Sounds.emplace(name, sf::Sound(m_SoundBuffers.at(name))); 
	}

	void Assets::AddAnimation(const std::string& name, const Graphics::Animation& animation)
	{
		m_Animations.emplace(name, animation); 
	}

	sf::Texture& Assets::GetTexture(const std::string& name) {
		assert(m_Textures.find(name) != m_Textures.end() && "Texture not found!");
		return m_Textures.at(name);
	}

	sf::Font& Assets::GetFont(const std::string& name) {
		assert(m_Fonts.find(name) != m_Fonts.end() && "Font not found!");
		return m_Fonts.at(name);
	}

	sf::Sound& Assets::GetSound(const std::string& name) {
		assert(m_Sounds.find(name) != m_Sounds.end() && "Sound not found!");
		return m_Sounds.at(name);
	}

	Graphics::Animation& Assets::GetAnimation(const std::string& name) {
		assert(m_Animations.find(name) != m_Animations.end() && "Animation not found!");
		return m_Animations.at(name);
	}

} 
#include "Core/GameEngine.h"

#include <iostream>

#include <imgui.h>
#include <imgui-SFML.h>

#include "Asset/Asset.h"
#include "Scene/Scene_Menu.h"

namespace Luden {

	GameEngine* GameEngine::s_Instance = nullptr;

	GameEngine::GameEngine(const std::string& assetPath) {
		Init(assetPath);
	}

	GameEngine::~GameEngine()
	{
		ImGui::SFML::Shutdown();
	}

	void GameEngine::Init(const std::string& assetPath) {
		m_Assets.LoadFromFile(assetPath);

		m_Window.create(sf::VideoMode(sf::Vector2u(1280, 720)), "Luden Engine", sf::State::Fullscreen);
		m_Window.setFramerateLimit(60);

		if (!ImGui::SFML::Init(m_Window)) {
			std::cerr << "ImGui-SFML initialization failed!" << std::endl;
		}

		// Default scene
		ChangeScene("MainMenu", std::make_shared<Scene_Menu>(this));
	}

	void GameEngine::Initialize(const std::string& assetPath) 
	{
		if (!s_Instance) 
		{
			s_Instance = new GameEngine(assetPath);
		}
	}

	void GameEngine::Run() {
		while (IsRunning()) {
			ProcessInput();
			ImGui::SFML::Update(m_Window, m_DeltaClock.restart());
			Update();
			ImGui::SFML::Render(m_Window);
			m_Window.display();
		}
	}

	void GameEngine::Update() {
		GetCurrentScene()->Update();
	}

	void GameEngine::ProcessInput()
	{
		while (const std::optional<sf::Event> event = m_Window.pollEvent())
		{
			ImGui::SFML::ProcessEvent(m_Window, *event);

			if (event->is<sf::Event::Closed>())
			{
				Quit();
				return;
			}

			if (const auto* keyPressed = event->getIf<sf::Event::KeyPressed>())
			{
				if (keyPressed->scancode == sf::Keyboard::Scancode::Escape)
					Quit();

				const auto& actionMap = GetCurrentScene()->GetActionMap();
				auto keyCode = static_cast<int>(keyPressed->code);
				auto it = actionMap.find(keyCode);
				if (it != actionMap.end())
					GetCurrentScene()->DoAction(Action(it->second, "START"));
			}

			if (const auto* keyReleased = event->getIf<sf::Event::KeyReleased>())
			{
				const auto& actionMap = GetCurrentScene()->GetActionMap();
				auto keyCode = static_cast<int>(keyReleased->code);
				auto it = actionMap.find(keyCode);
				if (it != actionMap.end())
					GetCurrentScene()->DoAction(Action(it->second, "END"));
			}

			if (const auto* mouseMoved = event->getIf<sf::Event::MouseMoved>())
			{
				Math::Vec2 pos = { static_cast<float>(mouseMoved->position.x), static_cast<float>(mouseMoved->position.y) };
				GetCurrentScene()->DoAction(Action("MOUSE_MOVE", pos));
			}

			if (ImGui::GetIO().WantCaptureMouse)
				continue;

			if (const auto* mousePressed = event->getIf<sf::Event::MouseButtonPressed>())
			{
				Math::Vec2 pos = { static_cast<float>(mousePressed->position.x), static_cast<float>(mousePressed->position.y) };
				std::string button;
				switch (mousePressed->button)
				{
				case sf::Mouse::Button::Left: button = "LEFT_CLICK"; break;
				case sf::Mouse::Button::Middle: button = "MIDDLE_CLICK"; break;
				case sf::Mouse::Button::Right: button = "RIGHT_CLICK"; break;
				default: break;
				}

				if (!button.empty())
				{
					GetCurrentScene()->DoAction(Action(button, "START", pos));
				}
			}

			if (const auto* mouseReleased = event->getIf<sf::Event::MouseButtonReleased>())
			{
				Math::Vec2 pos = { static_cast<float>(mouseReleased->position.x), static_cast<float>(mouseReleased->position.y) };
				std::string button;
				switch (mouseReleased->button)
				{
				case sf::Mouse::Button::Left: button = "LEFT_CLICK"; break;
				case sf::Mouse::Button::Middle: button = "MIDDLE_CLICK"; break;
				case sf::Mouse::Button::Right: button = "RIGHT_CLICK"; break;
				default: break;
				}
				if (!button.empty())
					GetCurrentScene()->DoAction(Action(button, "END", pos));
			}
		}
	}

	bool GameEngine::IsRunning() const 
	{
		return m_IsRunning && m_Window.isOpen();
	}

	void GameEngine::Quit() 
	{
		m_IsRunning = false;
		m_Window.close();
	}

	void GameEngine::Shutdown() 
	{
		if (s_Instance) {
			delete s_Instance;
			s_Instance = nullptr;
		}
	}

	void GameEngine::ChangeScene(const std::string& name, std::shared_ptr<Scene> scene, bool endCurrent) 
	{
		m_CurrentSceneName = name;
		m_SceneMap[name] = std::move(scene);
	}

	GameEngine& GameEngine::Get() 
	{
		if (!s_Instance) 
		{
			throw std::runtime_error("GameEngine not initialized! Use Initialize() first.");
		}
		return *s_Instance;
	}

	std::shared_ptr<Scene> GameEngine::GetCurrentScene() {
		return m_SceneMap.at(m_CurrentSceneName);
	}

	sf::RenderWindow& GameEngine::GetWindow() {
		return m_Window;
	}

	Assets& GameEngine::GetAssets() {
		return m_Assets;
	}
}
#include "ECS/Entity.h"

#include <vector>

#include "ECS/EntityManager.h"

namespace Luden
{
	Entity::Entity(EntityID id) 
		: m_ID(id) {}

	bool Entity::IsActive() const 
	{
		return EntityManager::Instance().IsActive(m_ID);
	}

	const std::string& Entity::Tag() const 
	{
		return EntityManager::Instance().GetTag(m_ID);
	}

	size_t Entity::Id() const 
	{
		return m_ID;
	}

	void Entity::Destroy() 
	{
		EntityManager::Instance().DestroyEntity(m_ID);
	}
}
#include "ECS/EntityManager.h"

#include "ECS/Entity.h"


namespace Luden
{
	EntityManager::EntityManager(size_t maxEntities)
	{
		m_Tags.resize(maxEntities);
		m_Active.resize(maxEntities);

		std::apply([maxEntities](auto&... vecs)
		{
			(..., vecs.resize(maxEntities));
		}, m_Pool);
	}

	EntityID EntityManager::GetNextIndex()
	{
		for (EntityID i = 0; i < MAX_ENTITIES; ++i)
		{
			if (!m_Active[i])
				return i;
		}

		assert(false && "Entity limit reached!");
		return MAX_ENTITIES - 1;
	}

	Entity EntityManager::AddEntity(const std::string& tag)
	{
		EntityID index = GetNextIndex();
		m_Tags[index] = tag;
		m_Active[index] = true;
		return Entity(index);
	}

	void EntityManager::DestroyEntity(EntityID entityID)
	{
		m_Active[entityID] = false;
	}
}
#include <rttr/registration>
using namespace rttr;

#include "../../include/ECS/Components/Components.h"
#include "../../include/ECS/IComponent.h"
#include "../../include/Asset/Asset.h"
#include "../../include/Input/Action.h"
#include "../../include/ECS/Entity.h"
#include "../../include/ECS/EntityManager.h"
#include "../../include/Core/GameEngine.h"
#include "../../include/Scene/Scene.h"
#include "../../include/Scene/Scene_Menu.h"
#include "../../include/Scene/Scene_Zelda.h"
#include "../../include/ECS/ISystem.h"

RTTR_REGISTRATION
{
	registration::class_<Luden::IComponent>("IComponent")
		.property("has", &Luden::IComponent::has)
		(
			metadata("default", false)
		);

	registration::class_<Luden::CDamage>("CDamage")
		.constructor<>()
		.constructor<int>()
		.property("damage", &Luden::CDamage::damage)
		(
			metadata("default", 1)
		);

	registration::class_<Luden::CDraggable>("CDraggable")
		.constructor<>()
		.property("dragging", &Luden::CDraggable::dragging)
		(
			metadata("default", false)
		);

	registration::class_<Luden::CFollowPlayer>("CFollowPlayer")
		.constructor<>()
		.constructor<Luden::Math::Vec2, float>()
		.property("home", &Luden::CFollowPlayer::home)
		(
			metadata("default", Luden::Math::Vec2{ 0.0f, 0.0f })
		)
		.property("speed", &Luden::CFollowPlayer::speed)
		(
			metadata("default", 0.0f)
		);

	registration::class_<Luden::CGravity>("CGravity")
		.constructor<>()
		.constructor<float>()
		.property("gravity", &Luden::CGravity::gravity)
		(
			metadata("default", 0.0f)
		);

	registration::class_<Luden::CHealth>("CHealth")
		.constructor<>()
		.constructor<int, int>()
		.property("max", &Luden::CHealth::max)
		(
			metadata("default", 1)
		)
		.property("current", &Luden::CHealth::current)
		(
			metadata("default", 1)
		);

	registration::class_<Luden::CInput>("CInput")
		.constructor<>()
		.property("up", &Luden::CInput::up)
		(
			metadata("default", false)
		)
		.property("down", &Luden::CInput::down)
		(
			metadata("default", false)
		)
		.property("left", &Luden::CInput::left)
		(
			metadata("default", false)
		)
		.property("right", &Luden::CInput::right)
		(
			metadata("default", false)
		)
		.property("attack", &Luden::CInput::attack)
		(
			metadata("default", false)
		)
		.property("canAttack", &Luden::CInput::canAttack)
		(
			metadata("default", true)
		);

	registration::class_<Luden::CBoundingBox>("CBoundingBox")
		.constructor<>()
		.constructor<Luden::Math::Vec2&, Luden::Math::Vec2&, bool, bool>()
		.property("size", &Luden::CBoundingBox::size)
		.property("halfSize", &Luden::CBoundingBox::halfSize)
		.property("center", &Luden::CBoundingBox::center)
		.property("prevCenter", &Luden::CBoundingBox::prevCenter)
		.property("blockMove", &Luden::CBoundingBox::blockMove)
		(
			metadata("default", false)
		)
		.property("blockVision", &Luden::CBoundingBox::blockVision)
		(
			metadata("default", false)
		);

	registration::class_<Luden::CAnimation>("CAnimation")
		.constructor<>()
		.constructor<Luden::Graphics::Animation, bool>()
		.property("animation", &Luden::CAnimation::animation)
		.property("repeat", &Luden::CAnimation::repeat)
		(
			metadata("default", false)
		);

	registration::class_<Luden::CInvincibility>("CInvincibility")
		.constructor<>()
		.constructor<int>()
		.property("iframes", &Luden::CInvincibility::iframes)
		(
			metadata("default", 1)
		);

	registration::class_<Luden::CLifespan>("CLifespan")
		.constructor<>()
		.constructor<int, int>()
		.property("lifespan", &Luden::CLifespan::lifespan)
		(
			metadata("default", 0)
		)
		.property("frameCreated", &Luden::CLifespan::frameCreated)
		(
			metadata("default", 0)
		);

	registration::class_<Luden::CPatrol>("CPatrol")
		.constructor<>()
		.constructor<std::vector<Luden::Math::Vec2>&, float>()
		.property("positions", &Luden::CPatrol::positions)
		.property("currentPosition", &Luden::CPatrol::currentPosition)
		(
			metadata("default", 0)
		);

	registration::class_<Luden::CState>("CState")
		.constructor<>()
		.constructor<std::string>()
		.property("state", &Luden::CState::state)
		(
			metadata("default", "stand")
		)
		.property("previousState", &Luden::CState::previousState)
		(
			metadata("default", "stand")
		);

	registration::class_<Luden::CTransform>("CTransform")
		.constructor<>()
		.constructor<Luden::Math::Vec2&>()
		.constructor<Luden::Math::Vec2&, Luden::Math::Vec2&, Luden::Math::Vec2&, float>()
		.property("pos", &Luden::CTransform::pos)
		(
			metadata("default", Luden::Math::Vec2{ 0.0f, 0.0f })
		)
		.property("prevPos", &Luden::CTransform::prevPos)
		(
			metadata("default", Luden::Math::Vec2{ 0.0f, 0.0f })
		)
		.property("velocity", &Luden::CTransform::velocity)
		(
			metadata("default", Luden::Math::Vec2{ 0.0f, 0.0f })
		)
		.property("scale", &Luden::CTransform::scale)
		(
			metadata("default", Luden::Math::Vec2{ 1.0f, 1.0f })
		)
		.property("facing", &Luden::CTransform::facing)
		(
			metadata("default", Luden::Math::Vec2{ 0.0f, 1.0f })
		)
		.property("angle", &Luden::CTransform::angle)
		(
			metadata("default", 0.0f)
		);

	// Assets
	registration::class_<Luden::Assets>("Assets")
		.constructor<>()
		.property("m_Textures", &Luden::Assets::m_Textures)
		.property("m_Fonts", &Luden::Assets::m_Fonts)
		.property("m_SoundBuffers", &Luden::Assets::m_SoundBuffers)
		.property("m_Sounds", &Luden::Assets::m_Sounds)
		.property("m_Animations", &Luden::Assets::m_Animations);

	// Action
	registration::class_<Luden::Action>("Action")
		.constructor<>()
		.constructor<std::string, std::string>()
		.constructor<std::string, Luden::Math::Vec2>()
		.constructor<std::string, std::string, Luden::Math::Vec2>()
		.property("m_Name", &Luden::Action::m_Name)
		.property("m_Type", &Luden::Action::m_Type)
		.property("m_Pos", &Luden::Action::m_Pos);

	// Entity
	registration::class_<Luden::Entity>("Entity")
		.property("m_ID", &Luden::Entity::m_ID);

	// EntityManager
	registration::class_<Luden::EntityManager>("EntityManager")
		.property("m_NumEntities", &Luden::EntityManager::m_NumEntities)
		.property("m_Pool", &Luden::EntityManager::m_Pool)
		.property("m_Tags", &Luden::EntityManager::m_Tags)
		.property("m_Active", &Luden::EntityManager::m_Active);

	// GameEngine
	registration::class_<Luden::GameEngine>("GameEngine")
		//.method("GetWindow", &Luden::GameEngine::GetWindow)
		.method("GetAssets", &Luden::GameEngine::GetAssets)
		//.property("m_Window", &Luden::GameEngine::m_Window)
		.property("m_DeltaClock", &Luden::GameEngine::m_DeltaClock)
		.property("m_Assets", &Luden::GameEngine::m_Assets)
		.property("m_CurrentSceneName", &Luden::GameEngine::m_CurrentSceneName)
		.property("m_SceneMap", &Luden::GameEngine::m_SceneMap)
		.property("m_IsRunning", &Luden::GameEngine::m_IsRunning);

	// Scene
	registration::class_<Luden::Scene>("Scene")
		.property("m_Game", &Luden::Scene::m_Game)
		.property("m_ActionMap", &Luden::Scene::m_ActionMap)
		.property("m_Paused", &Luden::Scene::m_Paused)
		.property("m_HasEnded", &Luden::Scene::m_HasEnded)
		.property("m_CurrentFrame", &Luden::Scene::m_CurrentFrame);

	// Scene_Menu
	registration::class_<Luden::Scene_Menu>("Scene_Menu")
		.constructor<Luden::GameEngine*>()
		//.property("m_MenuText", &Luden::Scene_Menu::m_MenuText)
		.property("m_MenuStrings", &Luden::Scene_Menu::m_MenuStrings)
		//.property("m_MenuItems", &Luden::Scene_Menu::m_MenuItems)
		.property("m_Title", &Luden::Scene_Menu::m_Title)
		.property("m_SelectedMenuIndex", &Luden::Scene_Menu::m_SelectedMenuIndex)
		.property("m_LevelPaths", &Luden::Scene_Menu::m_LevelPaths);

	// Scene_Zelda
	registration::class_<Luden::Scene_Zelda>("Scene_Zelda")
		.constructor<Luden::GameEngine*, std::string&>()
		.property("m_LevelPath", &Luden::Scene_Zelda::m_LevelPath)
		.property("m_GridText", &Luden::Scene_Zelda::m_GridText)
		.property("m_MousePos", &Luden::Scene_Zelda::m_MousePos)
		.property("m_GridSize", &Luden::Scene_Zelda::m_GridSize)
		.property("m_DrawTextures", &Luden::Scene_Zelda::m_DrawTextures)
		.property("m_DrawCollision", &Luden::Scene_Zelda::m_DrawCollision)
		.property("m_DrawGrid", &Luden::Scene_Zelda::m_DrawGrid)
		.property("m_Follow", &Luden::Scene_Zelda::m_Follow)
		.property("m_PlayerConfig", &Luden::Scene_Zelda::m_PlayerConfig);

	// ISystem
	registration::class_<Luden::ISystem>("ISystem")
		.method("Update", &Luden::ISystem::Update);
}
#include "Graphics/Animation.h"

#include <cmath>
#include <utility>


namespace Luden::Graphics
{
	Animation::Animation(const std::string& name, const sf::Texture& texture)
		: Animation(name, texture, 1, 0) {}

	Animation::Animation(const std::string& name, const sf::Texture& texture, size_t frameCount, size_t speed)
		: m_Name(name), m_Sprite(texture), m_FrameCount(frameCount), m_CurrentFrame(0), m_Speed(speed)
	{
		m_Size = Math::Vec2(
			static_cast<float>(texture.getSize().x) / static_cast<float>(frameCount),
			static_cast<float>(texture.getSize().y)
		);

		m_Sprite.setOrigin(sf::Vector2f(m_Size.x / 2.0f, m_Size.y / 2.0f));

		m_Sprite.setTextureRect(sf::IntRect(
			sf::Vector2i(static_cast<int>(m_CurrentFrame * m_Size.x), 0),			// Origin
			sf::Vector2i(static_cast<int>(m_Size.x), static_cast<int>(m_Size.y)))	// Width, Height
		);
	}

	void Animation::Update()
	{
		m_CurrentFrame++;
		size_t frame = (m_CurrentFrame / m_Speed) % m_FrameCount;
		m_Sprite.setTextureRect(sf::IntRect(
			sf::Vector2i(static_cast<int>(frame * m_Size.x), 0),					// Origin
			sf::Vector2i(static_cast<int>(m_Size.x), static_cast<int>(m_Size.y)))	// Width, Height
		);
	}

	bool Animation::HasEnded() const
	{
		if (m_Speed == 0) return true;

		return (m_CurrentFrame / m_Speed) % m_FrameCount == m_FrameCount - 1;
	}

	const std::string& Animation::GetName() const
	{
		return m_Name;
	}

	const Math::Vec2& Animation::GetSize() const
	{
		return m_Size;
	}

	const sf::Sprite& Animation::GetSprite() const
	{
		return m_Sprite;
	}

	sf::Sprite& Animation::GetSprite()
	{
		return m_Sprite;
	}
}
#include "Input/Action.h"

#include <sstream>

namespace Luden {

	Action::Action(std::string name, std::string type)
		: m_Name(std::move(name)), m_Type(std::move(type)) {
	}

	Action::Action(std::string name, Math::Vec2 pos)
		: m_Name(std::move(name)), m_Pos(pos) {
	}

	Action::Action(std::string name, std::string type, Math::Vec2 pos)
		: m_Name(std::move(name)), m_Type(std::move(type)), m_Pos(pos) {
	}

	const std::string& Action::Name() const {
		return m_Name;
	}

	const std::string& Action::Type() const {
		return m_Type;
	}

	const Math::Vec2& Action::Pos() const {
		return m_Pos;
	}

	std::string Action::ToString() const {
		std::stringstream ss;
		ss << m_Name << " " << m_Type << " "
			<< static_cast<int>(m_Pos.x) << " "
			<< static_cast<int>(m_Pos.y);
		return ss.str();
	}

}
#include <cmath>
#include "Math/Vec2.h"

namespace Luden::Math
{
	float Vec2::epsilon = 0.001f;

	const Vec2 Vec2::kZero{ 0.0f, 0.0f };

	Vec2::Vec2() = default;

	Vec2::Vec2(float xin, float yin) : x(xin), y(yin) {}

	Vec2 Vec2::operator*(const float val) const {
		return { x * val, y * val };
	}

	Vec2 Vec2::operator/(const float val) const {
		return { x / val, y / val };
	}

	Vec2 Vec2::operator+=(Vec2 rhs) {
		x += rhs.x;
		y += rhs.y;
		return *this;
	}

	Vec2 Vec2::operator-=(Vec2 rhs) {
		x -= rhs.x;
		y -= rhs.y;
		return *this;
	}

	Vec2 Vec2::operator*=(const float val) {
		x *= val;
		y *= val;
		return *this;
	}

	Vec2 Vec2::operator/=(const float val) {
		x /= val;
		y /= val;
		return *this;
	}

	bool Vec2::operator==(const Vec2& rhs) const {
		return x == rhs.x && y == rhs.y;
	}

	bool Vec2::operator!=(const Vec2& rhs) const {
		return x != rhs.x || y != rhs.y;
	}

	float Vec2::Length() const {
		return std::sqrt(x * x + y * y);
	}

	float Vec2::LengthSquared() const {
		return x * x + y * y;
	}

	Vec2 Vec2::Normalize() {
		float l = Length();
		x /= l;
		y /= l;
		return *this;
	}

	float Point2::epsilon = 0.001f;

	const Point2 Point2::kOrigin{ 0.0f, 0.0f };

	Point2::Point2() = default;

	Point2::Point2(float xin, float yin) : x(xin), y(yin) {}

	bool Point2::operator==(const Point2& rhs) const {
		return x == rhs.x && y == rhs.y;
	}

	bool Point2::operator!=(const Point2& rhs) const {
		return x != rhs.x || y != rhs.y;
	}

	float Point2::Distance(Point2 p) const {
		// float dx = rhs.x - x;
		// float dy = rhs.y - y;
		// return std::sqrt(dx * dx + dy * dy);
		return (p - *this).Length();
	}

	float Point2::DistanceSquared(Point2 p) const {
		return (p - *this).LengthSquared();
	}

	Vec2 operator+(Vec2 lhs, Vec2 rhs) {
		return { lhs.x + rhs.x, lhs.y + rhs.y };
	}

	Point2 operator+(Point2 lhs, Vec2 rhs) {
		return { lhs.x + rhs.x, lhs.y + rhs.y };
	}

	Vec2 operator-(Vec2 lhs, Vec2 rhs) {
		return { lhs.x - rhs.x, lhs.y - rhs.y };
	}

	Vec2 operator-(Point2 lhs, Point2 rhs) {
		return { lhs.x - rhs.x, lhs.y - rhs.y };
	}

	Vec2 operator*(float val, Vec2 lhs) {
		return { lhs.x * val, lhs.y * val };
	}

	bool Equals(Vec2 lhs, Vec2 rhs) {
		float dx = std::abs(lhs.x - rhs.x);
		float dy = std::abs(lhs.y - rhs.y);
		return dx <= Vec2::epsilon && dy <= Vec2::epsilon;
	}

	bool Equals(Point2 lhs, Point2 rhs) {
		float dx = std::abs(lhs.x - rhs.x);
		float dy = std::abs(lhs.y - rhs.y);
		return dx <= Point2::epsilon && dy <= Point2::epsilon;
	}

	float Length(Vec2 a) {
		return a.Length();
	}

	float LengthSquared(Vec2 a) {
		return a.LengthSquared();
	}

	Vec2 Normalize(Vec2 a) {
		a.Normalize();
		return a;
	}

	float Dot(Vec2 lhs, Vec2 rhs) {
		return lhs.x * rhs.x + lhs.y * rhs.y;
	}

	float Distance(Point2 lhs, Point2 rhs) {
		return (lhs - rhs).Length();
	}

	float DistanceSquared(Point2 lhs, Point2 rhs) {
		return (lhs - rhs).LengthSquared();
	}

	float AngleRadians(Vec2 lhs, Vec2 rhs) {
		if (lhs == rhs) return 0.0;

		lhs.Normalize();
		rhs.Normalize();

		float d = Dot(lhs, rhs);
		if (std::abs(d - 1.0f) < Vec2::epsilon) {
			d = 1.0f;
		}

		return std::acos(d);
	}

	float AngleDegrees(Vec2 lhs, Vec2 rhs) {
		float a = AngleRadians(lhs, rhs);
		return a * 180.0f / 3.14159265359f;
	}

	bool Clockwise(Vec2 lhs, Vec2 rhs) {
		float cross = lhs.x * rhs.y - lhs.y * rhs.x;
		return cross < 0;
	}

	bool CounterClockwise(Vec2 lhs, Vec2 rhs) {
		float cross = lhs.x * rhs.y - lhs.y * rhs.x;
		return cross >= 0;
	}
}
#include "Physics/Physics.h"

#include "ECS/Components/Components.h"

namespace Luden
{
	Math::Vec2 Physics::GetOverlap(const std::shared_ptr<Entity>& a, const std::shared_ptr<Entity>& b)
	{
		Math::Vec2 posA = a->Get<CTransform>().pos;
		Math::Vec2 posB = b->Get<CTransform>().pos;
		Math::Vec2 halfA = a->Get<CBoundingBox>().halfSize;
		Math::Vec2 halfB = b->Get<CBoundingBox>().halfSize;

		Math::Vec2 delta{ std::abs(posA.x - posB.x), std::abs(posA.y - posB.y) };
		return halfA + halfB - delta;
	}

	Math::Vec2 Physics::GetPreviousOverlap(const std::shared_ptr<Entity>& a, const std::shared_ptr<Entity>& b)
	{
		Math::Vec2 posA = a->Get<CTransform>().prevPos;
		Math::Vec2 posB = b->Get<CTransform>().prevPos;
		Math::Vec2 halfA = a->Get<CBoundingBox>().halfSize;
		Math::Vec2 halfB = b->Get<CBoundingBox>().halfSize;

		Math::Vec2 delta{ std::abs(posA.x - posB.x), std::abs(posA.y - posB.y) };
		return halfA + halfB - delta;
	}

	bool Physics::IsInside(const Math::Vec2& pos, const std::shared_ptr<Entity>& entity)
	{
		auto anim = entity->Get<CAnimation>().animation;
		Math::Vec2 size = anim->GetSize();
		Math::Vec2 ePos = entity->Get<CTransform>().pos;

		return (pos.x > ePos.x - size.x / 2 && 
				pos.x < ePos.x + size.x / 2 &&
				pos.y > ePos.y - size.y / 2 && 
				pos.y < ePos.y + size.y / 2
			);
	}

	Intersect Physics::LineIntersect(const Math::Vec2& a, const Math::Vec2& b, const Math::Vec2& c, const Math::Vec2& d)
	{
		Math::Vec2 r = b - a;
		Math::Vec2 s = d - c;
		float rxs = r.x * s.y - r.y * s.x;
		Math::Vec2 cma = c - a;

		if (rxs == 0.0f)
			return { false, Math::Vec2(0, 0) };

		float t = (cma.x * s.y - cma.y * s.x) / rxs;
		float u = (cma.x * r.y - cma.y * r.x) / rxs;

		if (t >= 0 && t <= 1 && u >= 0 && u <= 1)
			return { true, a + t * r };
		else
			return { false, Math::Vec2(0, 0) };
	}

	bool Physics::EntityIntersect(const Math::Vec2& a, const Math::Vec2& b, const std::shared_ptr<Entity>& entity)
	{
		auto boxC = entity->Get<CBoundingBox>().center;
		auto box = entity->Get<CBoundingBox>().halfSize;

		Math::Vec2 e1{ boxC.x - box.x, boxC.y - box.y };
		Math::Vec2 e2{ boxC.x + box.x, boxC.y - box.y };
		Math::Vec2 e3{ boxC.x + box.x, boxC.y + box.y };
		Math::Vec2 e4{ boxC.x - box.x, boxC.y + box.y };

		return LineIntersect(a, b, e1, e2).hit ||
			   LineIntersect(a, b, e2, e3).hit ||
			   LineIntersect(a, b, e3, e4).hit ||
			   LineIntersect(a, b, e4, e1).hit;
	}

	RectOverlap Physics::AIsNearB(const std::shared_ptr<Entity>& a, const std::shared_ptr<Entity>& b, const Math::Vec2& maxDist)
	{
		ODirection dir = ODirection::NONE;
		Math::Vec2 overlap = GetOverlap(a, b);
		Math::Vec2 prevOverlap = GetPreviousOverlap(a, b);

		float dy = b->Get<CTransform>().pos.y - a->Get<CTransform>().pos.y;
		if (overlap.x > 0 && overlap.y > 0 && -maxDist.y < overlap.y && prevOverlap.y <= 0)
		{
			dir = dy > 0 ? ODirection::UP : ODirection::DOWN;
		}

		float dx = b->Get<CTransform>().pos.x - a->Get<CTransform>().pos.x;
		if (overlap.y > 0 && overlap.x > 0 && -maxDist.x < overlap.x && prevOverlap.x <= 0)
		{
			dir = dx > 0 ? ODirection::LEFT : ODirection::RIGHT;
		}

		return { dir, overlap };
	}

	Math::Vec2 Physics::GetSpeedAB(const Math::Vec2& posA, const Math::Vec2& posB, float speed)
	{
		float theta = std::atan2(posB.y - posA.y, posB.x - posA.x);
		return Math::Vec2(speed * std::cos(theta), speed * std::sin(theta));
	}
}
#include "Scene/Scene.h"
#include "Core/GameEngine.h"
#include <SFML/Graphics.hpp>

namespace Luden
{
	Scene::Scene(GameEngine* gameEngine)
		: m_Game(gameEngine) {
	}

	void Scene::SetPaused(bool paused)
	{
		m_Paused = paused;
	}

	void Scene::DoAction(const Action& action)
	{
		sDoAction(action);
	}

	void Scene::Simulate(size_t frames)
	{
		for (size_t i = 0; i < frames; i++)
		{
			Update();
			m_CurrentFrame++;
		}
	}

	void Scene::RegisterAction(sf::Keyboard::Key inputKey, const std::string& actionName)
	{
		m_ActionMap[static_cast<int>(inputKey)] = actionName;
	}

	float Scene::Width() const
	{
		return static_cast<float>(m_Game->GetWindow().getSize().x);
	}

	float Scene::Height() const
	{
		return static_cast<float>(m_Game->GetWindow().getSize().y);
	}

	size_t Scene::CurrentFrame() const
	{
		return m_CurrentFrame;
	}

	bool Scene::HasEnded() const
	{
		return m_HasEnded;
	}

	const ActionMap& Scene::GetActionMap() const
	{
		return m_ActionMap;
	}
	
	void Scene::DrawLine(const Math::Vec2& p1, const Math::Vec2& p2)
	{
		sf::Vertex line[] = {
			sf::Vertex(sf::Vector2f(p1.x, p1.y)),
			sf::Vertex(sf::Vector2f(p2.x, p2.y))
		};

		m_Game->GetWindow().draw(line, 2, sf::PrimitiveType::Lines);
	}
}
#include "Scene/Scene_Menu.h"

#include <iostream>

#include <SFML/Graphics/View.hpp>
#include <SFML/Window.hpp>

#include "Core/GameEngine.h"
#include "Scene/Scene_Zelda.h"

namespace Luden 
{

	Scene_Menu::Scene_Menu(GameEngine* game)
		: Scene(game),
		m_TitleMusic(m_Game->GetAssets().GetSound("STitleTheme")),
		m_MenuText(m_Game->GetAssets().GetFont("Mario"), "")
	{
		Init();
	}

	void Scene_Menu::Init() 
	{
		sf::View view = m_Game->GetWindow().getView();
		view.setCenter(sf::Vector2f(
			static_cast<float>(m_Game->GetWindow().getSize().x) / 2.0f,
			static_cast<float>(m_Game->GetWindow().getSize().y) / 2.0f)
		);
		m_Game->GetWindow().setView(view);

		RegisterAction(sf::Keyboard::Key::W, "UP");
		RegisterAction(sf::Keyboard::Key::S, "DOWN");
		RegisterAction(sf::Keyboard::Key::D, "PLAY");
		RegisterAction(sf::Keyboard::Key::M, "MUTE");
		RegisterAction(sf::Keyboard::Key::Escape, "QUIT");

		m_TitleMusic = m_Game->GetAssets().GetSound("STitleTheme");
		m_TitleMusic.setLooping(true);
		m_TitleMusic.play();

		m_Title = "Lunatics";
		int titleSize = 30;
		m_MenuText.setString(m_Title);
		m_MenuText.setFont(m_Game->GetAssets().GetFont("Mario"));
		m_MenuText.setCharacterSize(titleSize);
		m_MenuText.setFillColor(sf::Color::Black);
		m_MenuText.setPosition(sf::Vector2f(
			float(m_Game->GetWindow().getSize().x) / 2.0f - float(titleSize * (m_Title.length() + 1)) / 2.0f,
			float(titleSize * 3)
		));

		m_MenuStrings.emplace_back("LEVEL 1");
		m_MenuStrings.emplace_back("LEVEL 2");
		m_MenuStrings.emplace_back("LEVEL 3");

		m_LevelPaths.emplace_back("config/level1.txt");
		m_LevelPaths.emplace_back("config/level2.txt");
		m_LevelPaths.emplace_back("config/level3.txt");

		for (const auto& menuString: m_MenuStrings) 
		{
			sf::Text text(m_Game->GetAssets().GetFont("Mario"), menuString, 26);
			text.setFillColor(sf::Color::Black);
			m_MenuItems.push_back(text);
		}
	}

	void Scene_Menu::Update() 
	{
		sRender();
	}

	void Scene_Menu::OnEnd() 
	{
		m_Game->Quit();
	}

	void Scene_Menu::sDoAction(const Action& action) 
	{
		if (action.Type() == "START") 
		{
			if (action.Name() == "UP") 
			{
				m_SelectedMenuIndex = (m_SelectedMenuIndex > 0) ? m_SelectedMenuIndex - 1 : static_cast<int>(m_MenuStrings.size()) - 1;
			}
			else if (action.Name() == "DOWN") 
			{
				m_SelectedMenuIndex = (m_SelectedMenuIndex + 1) % m_MenuStrings.size();
			}
			else if (action.Name() == "PLAY") 
			{
				m_TitleMusic.stop();
				m_Game->ChangeScene("PLAY", std::make_shared<Scene_Zelda>(m_Game, m_LevelPaths[m_SelectedMenuIndex]));
			}
			else if (action.Name() == "MUTE") 
			{
				if (m_TitleMusic.getStatus() == sf::SoundSource::Status::Playing) 
				{
					m_TitleMusic.stop();
				}
				else 
				{
					m_TitleMusic.play();
				}
			}
			else if (action.Name() == "QUIT") {
				OnEnd();
			}
		}
	}

	void Scene_Menu::sRender()
	{
		m_Game->GetWindow().clear(sf::Color(100, 100, 255));
		m_Game->GetWindow().draw(m_MenuText);

		for (size_t i = 0; i < m_MenuItems.size(); i++) 
		{
			auto& item = m_MenuItems[i];
			item.setFillColor(i == m_SelectedMenuIndex ? sf::Color::White : sf::Color::Black);
			item.setPosition(sf::Vector2f(
				float(m_Game->GetWindow().getSize().x) / 2.0f - float(26 * (m_MenuStrings[i].length() + 1)) / 2.0f,
				m_MenuText.getGlobalBounds().position.x + 10.0f + 30.0f * float(i + 1)
			));
			m_Game->GetWindow().draw(item);
		}

		sf::Text help(m_Game->GetAssets().GetFont("Mario"), "W:UP  S:DOWN  D:PLAY  M:MUTE  ESC:QUIT", 20);
		help.setFillColor(sf::Color::Black);
		help.setPosition(sf::Vector2f(20, float(m_Game->GetWindow().getSize().y) - 40));
		m_Game->GetWindow().draw(help);
	}
}
#include "Scene/Scene_Zelda.h"
#include "Core/GameEngine.h"
#include "ECS/Components/Components.h"
#include "ECS/EntityManager.h"
#include "Physics/Physics.h"

#include <fstream>
#include <iostream>

#include <imgui.h>
#include <imgui-SFML.h>

namespace Luden 
{
	Scene_Zelda::Scene_Zelda(GameEngine* game, std::string& levelPath)
		: Scene(game), m_LevelPath(levelPath),
		m_GridText(m_Game->GetAssets().GetFont("Tech"), "")
	{
		Init(m_LevelPath);
	}

	void Scene_Zelda::Init(const std::string& levelPath) 
	{
		LoadLevel(levelPath);

		m_GridText.setCharacterSize(12);
		m_GridText.setFont(m_Game->GetAssets().GetFont("Tech"));

		RegisterAction(sf::Keyboard::Key::Escape, "QUIT");
		RegisterAction(sf::Keyboard::Key::P, "PAUSE");
		RegisterAction(sf::Keyboard::Key::Y, "TOGGLE_FOLLOW");
		RegisterAction(sf::Keyboard::Key::T, "TOGGLE_TEXTURE");
		RegisterAction(sf::Keyboard::Key::C, "TOGGLE_COLLISION");
		RegisterAction(sf::Keyboard::Key::G, "TOGGLE_GRID");

		RegisterAction(sf::Keyboard::Key::W, "UP");
		RegisterAction(sf::Keyboard::Key::S, "DOWN");
		RegisterAction(sf::Keyboard::Key::A, "LEFT");
		RegisterAction(sf::Keyboard::Key::D, "RIGHT");
		RegisterAction(sf::Keyboard::Key::Space, "ATTACK");
	}

	void Scene_Zelda::LoadLevel(const std::string& fileName) 
	{
		std::ifstream file(fileName);
		if (!file) 
		{
			std::cerr << "Scene_Zelda::LoadLevel failed: " << fileName << std::endl;
			return;
		}

		std::string entityType;
		while (file >> entityType) 
		{
			if (entityType == "Tile") 
			{
				std::string animationName;
				int roomX, roomY, tileX, tileY, blockMovement, blockVision;
				file >> animationName >> roomX >> roomY >> tileX >> tileY >> blockMovement >> blockVision;

				auto tile = EntityManager::Instance().AddEntity("Tile");
				tile.Add<CAnimation>(m_Game->GetAssets().GetAnimation(animationName), true);
				tile.Add<CTransform>(GetPosition(roomX, roomY, tileX, tileY));
				tile.Add<CBoundingBox>(tile.Get<CTransform>().pos, tile.Get<CAnimation>().animation->GetSize(), blockMovement, blockVision);
				tile.Add<CDraggable>();
			}
			else if (entityType == "NPC") 
			{
				// benzer NPC ykleme kodlar buraya gelir...
			}
			else if (entityType == "Player") 
			{
				file >> m_PlayerConfig.X >> m_PlayerConfig.Y >> m_PlayerConfig.CX >> m_PlayerConfig.CY >> m_PlayerConfig.SPEED >> m_PlayerConfig.HEALTH;
				SpawnPlayer();
			}
			else {
				std::cerr << "Unknown entity type: " << entityType << std::endl;
			}
		}
	}

	Math::Vec2 Scene_Zelda::GetPosition(int rx, int ry, int tx, int ty) const 
	{
		return {
			rx * Width() + m_GridSize.x * tx - m_GridSize.x / 2.0f,
			ry * Height() + m_GridSize.y * ty - m_GridSize.y / 2.0f
		};
	}

	Math::Vec2 Scene_Zelda::GetRoomXY(const Math::Vec2& pos)
	{
		return Math::Vec2();
	}

	void Scene_Zelda::SpawnPlayer()
	{
		/*
		auto player = EntityManager::Instance().AddEntity("player");
		player.Add<CTransform>(Math::Vec2(m_PlayerConfig.X, m_PlayerConfig.Y));
		player.Add<CAnimation>(m_Game->GetAssets().GetAnimation("LinkStandDown"), true);
		player.Add<CBoundingBox>(Math::Vec2(m_PlayerConfig.X, m_PlayerConfig.Y), Math::Vec2(m_PlayerConfig.CX, m_PlayerConfig.CY), true, false);
		player.Add<CDraggable>();
		player.Add<CHealth>(m_PlayerConfig.HEALTH, m_PlayerConfig.HEALTH);
		player.Add<CState>("stand_down");
		*/
	}

	void Scene_Zelda::SpawnSword(const Entity& entity)
	{
	}

	void Scene_Zelda::player()
	{
		return;
	}


	Math::Vec2 Scene_Zelda::WindowToWorld(const Math::Vec2& pos) 
	{
		auto view = m_Game->GetWindow().getView();
		float wx = view.getCenter().x - Width() / 2.0f;
		float wy = view.getCenter().y - Height() / 2.0f;
		return { pos.x + wx, pos.y + wy };
	}

	void Scene_Zelda::ChangePlayerStateTo(const std::string& state, const Math::Vec2& facing)
	{
	}

	void Scene_Zelda::sDrag()
	{
	}

	void Scene_Zelda::sCamera()
	{
	}

	void Scene_Zelda::sGUI()
	{
		ImGui::Begin("Scene - Zelda");
		ImGui::Checkbox("Draw Textures", &m_DrawTextures);
		ImGui::Checkbox("Draw Collision", &m_DrawCollision);
		ImGui::Checkbox("Draw Grid", &m_DrawGrid);
		ImGui::Checkbox("Follow Camera", &m_Follow);
		ImGui::End();
	}

	void Scene_Zelda::sDoAction(const Action& action) {
		if (action.Type() == "START") 
		{
			if (action.Name() == "QUIT") OnEnd();
			else if (action.Name() == "TOGGLE_TEXTURE") m_DrawTextures = !m_DrawTextures;
			else if (action.Name() == "TOGGLE_COLLISION") m_DrawCollision = !m_DrawCollision;
			else if (action.Name() == "TOGGLE_GRID") m_DrawGrid = !m_DrawGrid;
		}
	}

	void Scene_Zelda::Update() {
		if (m_Paused) return;
		sGUI();
		sRender();
		m_CurrentFrame++;
	}

	void Scene_Zelda::sRender() {
		m_Game->GetWindow().clear(sf::Color(60, 60, 60));
		// render entities
		m_Game->GetWindow().display();
	}

	void Scene_Zelda::OnEnd() {
		// TODO
	}
	void Scene_Zelda::sAI()
	{
	}
	void Scene_Zelda::sStatus()
	{
	}
	void Scene_Zelda::sAnimation()
	{
	}
	void Scene_Zelda::sCollision()
	{
	}
	void Scene_Zelda::sMovement()
	{
	}
}
