#include "Core/EditorApp.h"

#include <iostream>


int main() {
	Luden::Editor::EditorApp editorApp;
	editorApp.Init();
	editorApp.Run();

	return 0;
}


#include "Core/EditorApp.h"

#include "Panels/SceneHierarchyPanel.h"
#include "Panels/AssetBrowserPanel.h"
#include "Panels/InspectorPanel.h"
#include "Panels/ConsolePanel.h"
#include "Panels/ProfilerPanel.h"
#include "Panels/SceneSettingsPanel.h"
#include "Core/EditorState.h"
#include "Scene/Scene_Zelda.h"
#include <iostream>

#include <imgui.h>
#include <imgui-SFML.h>
#include <imgui_internal.h>

namespace Luden::Editor {

	EditorApp::EditorApp() {}
	EditorApp::~EditorApp() { Shutdown(); }

	void EditorApp::Init() {
		// Load Editor State
		EditorState loaded = EditorState::Load("editor_state.json");
		EditorStateManager::Get().SetEditorMode(loaded.m_Mode);

		// Create Panels to draw
		m_Panels.clear();
		m_Panels.emplace_back(std::make_unique<SceneHierarchyPanel>());
		m_Panels.emplace_back(std::make_unique<AssetBrowserPanel>());

		for (auto& p : m_Panels) {
			auto it = loaded.m_PanelStates.find(p->GetName());
			p->m_Visible = (it != loaded.m_PanelStates.end()) ? it->second : true;
		}

		//Initialize Engine
		GameEngine::Initialize("config/assets.txt", true);

		m_Window.create(sf::VideoMode(sf::Vector2u(1280, 720)), "Luden Editor");
		m_Window.setFramerateLimit(60);
		if (!m_ViewportTexture.resize({ 1280, 720 }))
			throw std::runtime_error("Failed to resize viewport texture");
		m_ViewportTextureID = (ImTextureID)(intptr_t)m_ViewportTexture.getTexture().getNativeHandle();

		if (!ImGui::SFML::Init(m_Window))
			return;

		ImGui::StyleColorsDark();
		ImGuiIO& io = ImGui::GetIO();
		io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;

		m_IsRunning = true;
	}

	void EditorApp::Run() {
		std::vector<sf::Event> sfEvents;
		while (m_IsRunning && m_Window.isOpen()) {
			sfEvents.clear();
			while (const std::optional<sf::Event> event = m_Window.pollEvent()) {
				if (event.has_value())
				{
					sfEvents.emplace_back(event.value());
					ImGui::SFML::ProcessEvent(m_Window, event.value());
				}

				if (event->is<sf::Event::Closed>())
					m_IsRunning = false;
			}

			float dt = m_DeltaClock.restart().asSeconds();
			ImGui::SFML::Update(m_Window, sf::seconds(dt));

			if (EditorStateManager::Get().IsPlayMode()) {
				GameEngine::Get().ProcessInput(sfEvents, ImGui::GetIO().WantCaptureMouse);
				GameEngine::Get().Update(dt);
				GameEngine::Get().Render(m_ViewportTexture);
			}

			RenderDockSpace();
			RenderModeToolbar();
			for (auto& panel : m_Panels) panel->Render();
			Render();

			ImGui::SFML::Render(m_Window);
			m_Window.display();
		}
	}

	void EditorApp::Shutdown() {
		// Save Current Panel Visibilities
		EditorState& state = EditorStateManager::Get().GetState();
		state.m_Mode = EditorStateManager::Get().GetEditorMode();
		for (auto& p : m_Panels)
			state.m_PanelStates[p->GetName()] = p->m_Visible;
		state.Save("editor_state.json");

		ImGui::SFML::Shutdown();
		if (m_Window.isOpen()) m_Window.close();
		GameEngine::Shutdown();
	}

	void EditorApp::Render() {
		// viewport
		ImGui::Begin("Viewport");

		ImVec2 viewportPanelSize = ImGui::GetContentRegionAvail();
		sf::Vector2u newSize((unsigned int)viewportPanelSize.x, (unsigned int)viewportPanelSize.y);

		if (m_ViewportTexture.getSize() != newSize && newSize.x > 0 && newSize.y > 0)
		{
			m_ViewportTexture = sf::RenderTexture(newSize); 
			m_ViewportTextureID = (ImTextureID)(intptr_t)m_ViewportTexture.getTexture().getNativeHandle();
		}


		ImGui::Image(m_ViewportTextureID, viewportPanelSize, {0, 1}, {1, 0});

		ImGui::End();
	}

	void EditorApp::RenderDockSpace() {
		ImGuiWindowFlags flags = ImGuiWindowFlags_MenuBar | ImGuiWindowFlags_NoDocking;
		auto* vp = ImGui::GetMainViewport();
		ImGui::SetNextWindowPos(vp->WorkPos);
		ImGui::SetNextWindowSize(vp->WorkSize);
		ImGui::SetNextWindowViewport(vp->ID);
		flags |= ImGuiWindowFlags_NoTitleBar
			| ImGuiWindowFlags_NoResize
			| ImGuiWindowFlags_NoMove
			| ImGuiWindowFlags_NoCollapse
			| ImGuiWindowFlags_NoNavFocus
			| ImGuiWindowFlags_NoBringToFrontOnFocus;

		ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);
		ImGui::PushStyleVar(ImGuiStyleVar_WindowBorderSize, 0.0f);
		ImGui::Begin("#DockSpace", nullptr, flags);
		ImGui::PopStyleVar(2);

		ImGuiID dock_id = ImGui::GetID("EditorDockSpace");
		ImGui::DockSpace(dock_id, ImVec2(0, 0), ImGuiDockNodeFlags_None);

		if (!m_LayoutBuilt) {
			ImGuiIO& io = ImGui::GetIO();
			ImGuiID dock_id = ImGui::GetID("EditorDockSpace");
			ImGui::DockBuilderRemoveNode(dock_id);
			ImGui::DockBuilderAddNode(dock_id, ImGuiDockNodeFlags_None);
			ImGui::DockBuilderSetNodeSize(dock_id, io.DisplaySize);

			ImGuiID left = ImGui::DockBuilderSplitNode(dock_id, ImGuiDir_Left, 0.20f, nullptr, &dock_id);
			ImGuiID bottom = ImGui::DockBuilderSplitNode(dock_id, ImGuiDir_Down, 0.20f, nullptr, &dock_id);
			ImGuiID right = ImGui::DockBuilderSplitNode(dock_id, ImGuiDir_Right, 0.20f, nullptr, &dock_id);

			ImGui::DockBuilderDockWindow("Scene Hierarchy", left);
			ImGui::DockBuilderDockWindow("Assets", left);

			ImGui::DockBuilderFinish(dock_id);
			m_LayoutBuilt = true;
		}

		ImGui::End();
	}

	void EditorApp::RenderModeToolbar()
	{
		if (ImGui::Button("Edit")) {
			EditorStateManager::Get().SetEditorMode(EditorMode::Edit);
			GameEngine::Get().GetCurrentScene()->SetPaused(true);
		}

		ImGui::SameLine();
		if (ImGui::Button("Play")) {
			EditorStateManager::Get().SetEditorMode(EditorMode::Play);
			GameEngine::Get().GetCurrentScene()->SetPaused(false);
		}

		ImGui::SameLine();
		if (ImGui::Button("Pause")) {
			EditorStateManager::Get().SetEditorMode(EditorMode::Pause);
			GameEngine::Get().GetCurrentScene()->SetPaused(true);
		}

		ImGui::Text("Current Mode: %s",
			EditorStateManager::Get().IsEditMode() ? "Edit" :
			EditorStateManager::Get().IsPlayMode() ? "Play" :
			EditorStateManager::Get().IsPaused() ? "Pause" : "Unknown");
	}

	void EditorApp::HandleInput() {
		while (auto evt = m_Window.pollEvent()) {
			ImGui::SFML::ProcessEvent(m_Window, *evt);
			if (evt->is<sf::Event::Closed>())
				m_IsRunning = false;
		}
	}

} // namespace Luden::Editor
#include "Core/EditorState.h"

namespace Luden::Editor
{
	EditorStateManager& EditorStateManager::Get()
	{
		static EditorStateManager instance;
		return instance;
	}

	EditorMode EditorStateManager::GetEditorMode()
	{
		return EditorMode();
	}

	void EditorStateManager::SetEditorMode(EditorMode editorMode)
	{
		m_State.m_Mode = editorMode;
	}

	EditorState& Editor::EditorStateManager::GetState()
	{
		return m_State;
	}
	const EditorState& Editor::EditorStateManager::GetState() const
	{
		return m_State;
	}
}

#include "Panels/AssetBrowserPanel.h"
#include "Core/GameEngine.h"
#include "imgui.h"

#include <iostream>

#include <rttr/instance.h>
#include <rttr/type.h>
#include <rttr/variant.h>

namespace Luden::Editor
{
	void AssetBrowserPanel::Render()
	{
		if (!m_Visible) return;
		if (!ImGui::Begin("Assets", &m_Visible))
		{
			ImGui::End();
			return;
		}

		auto& engine = GameEngine::Get();
		rttr::instance inst = engine;
		rttr::type ge_t = rttr::type::get<decltype(engine)>();

		auto assets_prop = ge_t.get_property("m_Assets");
		rttr::variant assets_var = assets_prop.get_value(inst);

		if (!assets_prop.is_valid())
			std::cerr << "m_Assets property not valid\n";
		if (!assets_var.is_valid())
			std::cerr << "m_Assets value not valid\n";

		rttr::variant assets_ref = assets_var.extract_wrapped_value();
		rttr::instance assets_inst = assets_ref;
		rttr::type assets_t = assets_ref.get_type();

		for (auto prop : assets_t.get_properties())
		{
			if (!prop.get_type().is_associative_container())
				continue;

			ImGui::TextUnformatted(prop.get_name().data());
			ImGui::Separator();
			ImGui::Indent();

			auto view = prop.get_value(assets_inst).create_associative_view();
			for (auto& item : view)
			{
				std::string key = item.first.get_value<std::string>();
				if (ImGui::Selectable(key.c_str()))
				{
					// TODO: handle selecting that asset
				}
			}

			ImGui::Unindent();
			ImGui::Spacing();
		}

		ImGui::End();
	}
}
#include "Panels/Panel.h"

namespace Luden::Editor
{
	Panel::Panel(const std::string& name)
		: m_Name(name) {
	}

	const std::string& Panel::GetName() const
	{
		return m_Name;
	}
}
#include "Panels/SceneHierarchyPanel.h"
#include "ECS/EntityManager.h"
#include "ECS/Entity.h"
#include "imgui.h"

#include <iostream>

#include <rttr/instance.h>
#include <rttr/type.h>
#include <rttr/variant.h>

namespace Luden::Editor
{
	void SceneHierarchyPanel::Render()
	{
		if (!m_Visible) return;
		if (!ImGui::Begin("Scene Hierarchy", &m_Visible))
		{
			ImGui::End();
			return;
		}

		auto& mgr = Luden::EntityManager::Instance();
		rttr::instance inst = mgr;
		rttr::type t = rttr::type::get<Luden::EntityManager>();

		auto active_prop = t.get_property("m_Active");
		auto tags_prop = t.get_property("m_Tags");

		rttr::variant active_var = active_prop.get_value(inst);
		rttr::variant tags_var = tags_prop.get_value(inst);


		if (!active_prop.is_valid()) std::cerr << "m_Active not found\n";

		if (!active_var.is_valid()) std::cerr << "m_Active value invalid\n";

		auto active_view = active_var.create_sequential_view();
		auto tags_view = tags_var.create_sequential_view();

		const size_t N = tags_view.get_size();
		for (size_t i = 0; i < N; ++i)
		{
			bool alive = active_view.get_value(i).to_uint8() != 0;
			if (!alive)
				continue;

			//std::cout << "Tags type: " << tags_var.get_type().get_name().to_string() << "\n";
			//std::cout << "Is sequential: " << tags_var.get_type().is_sequential_container() << "\n";
			// tags are std::string
			auto tag_value = tags_view.get_value(i);
			if (!tag_value.is_valid() || !tag_value.is_type<std::string>()) {
				//std::cerr << "[SceneHierarchyPanel] Invalid tag at index " << i << "\n";
				continue;
			}

			std::string name = tag_value.get_value<std::string>();
			std::string label = "[" + std::to_string(i) + "] " + name;

			if (ImGui::Selectable(label.c_str(), false))
			{
				// TODO: handle selection of entity i
			}
		}

		ImGui::End();
	}
}
#pragma once

#ifdef EDITOR_EXPORTS
#define EDITOR_API __declspec(dllexport)
#else
#define EDITOR_API __declspec(dllimport)
#endif#pragma once

#include "EditorAPI.h"

#include <memory>
#include <vector>

#include "imgui.h"
#include "SFML/Graphics.hpp"
#include "SFML/System/Clock.hpp"
#include <rttr/registration_friend.h>

#include "EditorAPI.h"
#include "Panels/Panel.h"
#include "Core/GameEngine.h"

namespace Luden::Editor
{
	class EDITOR_API EditorApp
	{
	public:
		EditorApp();
		~EditorApp();
		void Init();
		void Run();
		void Shutdown();

	private:
		void Render();
		void RenderDockSpace();
		void RenderModeToolbar();
		void HandleInput();

	private:
		sf::RenderWindow m_Window;
		sf::Clock m_DeltaClock;
		std::vector<std::unique_ptr<Panel>> m_Panels;
		bool m_IsRunning = false;
		bool m_LayoutBuilt = false;

		sf::RenderTexture m_ViewportTexture;
		ImTextureID m_ViewportTextureID = 0;
	};
}#pragma once

#include "EditorAPI.h"

#include <nlohmann/json.hpp>

#include <map>
#include <string>
#include <fstream>

namespace Luden::Editor
{
	enum class EditorMode
	{
		Edit,
		Play,
		Pause
	};

	struct EditorState
	{
		EditorMode m_Mode = EditorMode::Edit;
		std::map<std::string, bool> m_PanelStates;

		static EditorState Load(const std::string& path)
		{
			EditorState state;
			std::ifstream ifs(path);
			if (!ifs.is_open())
				return state;

			nlohmann::json j;

			ifs >> j;
			auto s = j.value("Mode", std::string("Edit"));

			if (s == "Edit")
				state.m_Mode = EditorMode::Edit;
			else if (s == "Play")
				state.m_Mode = EditorMode::Play;
			else if (s == "Pause")
				state.m_Mode = EditorMode::Pause;
			
			if (j.contains("PanelStates") && j["PanelStates"].is_object())
			{
				for (auto& [key, value] : j["PanelStates"].items())
					state.m_PanelStates[key] = value.get<bool>();
			}
			return state;
		}

		void Save(const std::string& path) const 
		{
			nlohmann::json j;
			switch (m_Mode)
			{
			case EditorMode::Edit:
				j["Mode"] = "Edit";
				break;
			case EditorMode::Play:
				j["Mode"] = "Play";
				break;
			case EditorMode::Pause:
				j["Mode"] = "Pause";
				break;
			}
			j["PanelStates"] = m_PanelStates;
			
			std::ofstream(path) << j.dump(4);
		}
	};

	class EDITOR_API EditorStateManager
	{
	public:
		static EditorStateManager& Get();

		EditorMode GetEditorMode();
		void SetEditorMode(EditorMode editorMode);

		bool IsPlayMode() const { return m_State.m_Mode == EditorMode::Play; }
		bool IsEditMode() const { return m_State.m_Mode == EditorMode::Edit; }
		bool IsPaused()   const { return m_State.m_Mode == EditorMode::Pause; }

		EditorState& GetState();
		const EditorState& GetState() const;

	private:
		EditorStateManager() = default;
		EditorState m_State;
	};
}#pragma once
#pragma once

#include "EditorAPI.h"
#include "Panels/Panel.h"

namespace Luden::Editor
{
	class EDITOR_API AssetBrowserPanel : public Panel
	{
	public:
		AssetBrowserPanel() : Panel("Assets") {}
		void Render() override;
	};
}#pragma once
#pragma once
#pragma once

#include <string>

#include <rttr/registration.h>
#include <rttr/registration_friend.h>

#include "EditorAPI.h"

namespace Luden::Editor
{
	class EDITOR_API Panel
	{
		RTTR_ENABLE()
		RTTR_REGISTRATION_FRIEND
	public:
		Panel(const std::string& name);
		virtual ~Panel() = default;

		virtual void Render() = 0;
		const std::string& GetName() const;

		bool m_Visible = true;
	protected:
		std::string m_Name;
	};
}#pragma once
#pragma once

#include "EditorAPI.h"
#include "Panels/Panel.h"

namespace Luden::Editor
{
	class EDITOR_API SceneHierarchyPanel : public Panel
	{
	public:
		SceneHierarchyPanel() : Panel("Scene Hierarchy") {}
		void Render() override;
	};
}#pragma once
